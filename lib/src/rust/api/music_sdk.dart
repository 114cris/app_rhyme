// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.32.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'mirror.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// The type `POOL` is not used by any `pub` functions, thus it is ignored.

Future<List<MusicW>> searchMusic(
        {required String content,
        required int page,
        required String source,
        dynamic hint}) =>
    RustLib.instance.api
        .searchMusic(content: content, page: page, source: source, hint: hint);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::rust_async::RwLock<MusicW>>
@sealed
class MusicW extends RustOpaque {
  MusicW.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  MusicW.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_MusicW,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_MusicW,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_MusicWPtr,
  );

  String getExtraInto({required Quality quality, dynamic hint}) =>
      RustLib.instance.api
          .musicWGetExtraInto(that: this, quality: quality, hint: hint);

  int getMusicId({dynamic hint}) =>
      RustLib.instance.api.musicWGetMusicId(that: this, hint: hint);

  MusicInfo getMusicInfo({dynamic hint}) =>
      RustLib.instance.api.musicWGetMusicInfo(that: this, hint: hint);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::rust_async::RwLock<Pool < Any >>>
@sealed
class PoolAny extends RustOpaque {
  PoolAny.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  PoolAny.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_PoolAny,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_PoolAny,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_PoolAnyPtr,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::rust_async::RwLock<SqlMusicFactoryW>>
@sealed
class SqlMusicFactoryW extends RustOpaque {
  SqlMusicFactoryW.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  SqlMusicFactoryW.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_SqlMusicFactoryW,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_SqlMusicFactoryW,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_SqlMusicFactoryWPtr,
  );

  static Future<SqlMusicFactoryW> build(
          {required PoolAny pool, dynamic hint}) =>
      RustLib.instance.api.sqlMusicFactoryWBuild(pool: pool, hint: hint);

  Future<void> changeMusicData(
          {required List<MusicW> musics,
          required List<MusicInfo> infos,
          dynamic hint}) =>
      RustLib.instance.api.sqlMusicFactoryWChangeMusicData(
          that: this, musics: musics, infos: infos, hint: hint);

  Future<void> changeMusicDefaultSource(
          {required MusicList musicList,
          required Int64List ids,
          required List<String> defaultSources,
          dynamic hint}) =>
      RustLib.instance.api.sqlMusicFactoryWChangeMusicDefaultSource(
          that: this,
          musicList: musicList,
          ids: ids,
          defaultSources: defaultSources,
          hint: hint);

  Future<void> changeMusicListMetadata(
          {required List<MusicList> oldList,
          required List<MusicList> newList,
          dynamic hint}) =>
      RustLib.instance.api.sqlMusicFactoryWChangeMusicListMetadata(
          that: this, oldList: oldList, newList: newList, hint: hint);

  Future<void> cleanUnusedMusicData({dynamic hint}) => RustLib.instance.api
      .sqlMusicFactoryWCleanUnusedMusicData(that: this, hint: hint);

  Future<void> createMusicListTable(
          {required List<MusicList> musicLists, dynamic hint}) =>
      RustLib.instance.api.sqlMusicFactoryWCreateMusicListTable(
          that: this, musicLists: musicLists, hint: hint);

  Future<void> delMusic(
          {required MusicList musicList,
          required Int64List ids,
          dynamic hint}) =>
      RustLib.instance.api.sqlMusicFactoryWDelMusic(
          that: this, musicList: musicList, ids: ids, hint: hint);

  Future<void> delMusicListTable(
          {required List<MusicList> musicLists, dynamic hint}) =>
      RustLib.instance.api.sqlMusicFactoryWDelMusicListTable(
          that: this, musicLists: musicLists, hint: hint);

  Future<void> initCreateTable({dynamic hint}) => RustLib.instance.api
      .sqlMusicFactoryWInitCreateTable(that: this, hint: hint);

  Future<void> insertMusic(
          {required MusicList musicList,
          required List<MusicW> musics,
          dynamic hint}) =>
      RustLib.instance.api.sqlMusicFactoryWInsertMusic(
          that: this, musicList: musicList, musics: musics, hint: hint);

  Future<List<MusicW>> readMusic(
          {required MusicList musicList, dynamic hint}) =>
      RustLib.instance.api.sqlMusicFactoryWReadMusic(
          that: this, musicList: musicList, hint: hint);

  Future<List<MusicW>> readMusicData({required String source, dynamic hint}) =>
      RustLib.instance.api.sqlMusicFactoryWReadMusicData(
          that: this, source: source, hint: hint);

  Future<List<MusicList>> readMusicLists({dynamic hint}) => RustLib.instance.api
      .sqlMusicFactoryWReadMusicLists(that: this, hint: hint);

  Future<void> reorderMusic(
          {required MusicList musicList,
          required Int64List newIndex,
          required List<MusicW> oldMusicsInOrder,
          dynamic hint}) =>
      RustLib.instance.api.sqlMusicFactoryWReorderMusic(
          that: this,
          musicList: musicList,
          newIndex: newIndex,
          oldMusicsInOrder: oldMusicsInOrder,
          hint: hint);
}
